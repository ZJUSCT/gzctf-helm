gzctf:
  # -- Number of GZCTF replicas (Set to >1 for multi-node. Needs requirements)
  replicaCount: 1
  
  # -- Deployment strategy type
  strategyType: RollingUpdate

  # -- GZCTF container image configuration
  image:
    # -- GZCTF image repository
    repository: ghcr.io/gztimewalker/gzctf/gzctf
    # -- Image pull policy
    pullPolicy: Always
    # -- GZCTF image tag
    tag: "v1.6.2"

  # -- Secret configuration for sensitive data
  secret:
    # -- Create a secret for GZCTF (set to false to use an existing secret)
    create: true
    # -- Name of existing secret to use (if create is false)
    # existingSecret: "gzctf-existing-secret"
    # -- Admin password for GZCTF (if not set, a random password will be generated)
    # IMPORTANT: Leave empty on first install to auto-generate, then retrieve with:
    # kubectl get secret <release-name>-gzctf-secret -o jsonpath='{.data.admin-password}' | base64 -d
    adminPassword: ""

  # -- Environment variables for GZCTF container
  env:
    # -- Locale configuration
    - name: LC_ALL
      value: "en_US.UTF-8"

  # Kubernetes ClusterRole configuration for GZCTF
  clusterRole:
    # -- Create ClusterRole for GZCTF (required for Kubernetes challenge container management)
    create: true
    # -- ClusterRole rules (full cluster access for managing challenge containers)
    rules:
    - apiGroups:
      - '*'
      resources:
      - '*'
      verbs:
      - '*'
    - nonResourceURLs:
      - '*'
      verbs:
      - '*'

  # -- GZCTF application configuration (structured format)
  # This replaces the previous appsettings string with a structured configuration
  # that is more maintainable and follows Helm best practices
  config:
    allowedHosts: "*"

    # Database connection
    database:
      # Host will be auto-generated as <release-name>-postgresql:5432 when using built-in PostgreSQL
      # You can override it here if using external database
      # host: external-postgres:5432
      name: gzctf
      username: postgres
      # Password for PostgreSQL - CHANGE THIS!
      password: "gzctf"

    # Redis cache connection
    redis:
      # Host will be auto-generated based on enabled cache (garnet or redis-ha)
      # You can override it here if using external Redis
      # host: external-redis:6379
      abortConnect: false

    # Storage configuration (MinIO/S3)
    storage:
      # Enable S3-compatible storage (MinIO)
      # If not enabled, files will be stored locally in PVC
      enabled: false
      # Connection string will be auto-generated if using built-in MinIO
      # Format: minio.s3://serviceUrl=minio:9000;accessKey=key;secretKey=secret;bucket=bucket-name
      # You can override it here if using external S3
      # connectionString: "minio.s3://serviceUrl=s3.amazonaws.com;region=us-east-1;accessKey=xxx;secretKey=xxx;bucket=my-bucket"

    # Logging configuration
    logging:
      logLevel:
        default: Warning
        microsoft: Warning
        microsoftAspNetCoreHttpOverrides: Debug

    # XOR key for encryption - CHANGE THIS!
    xorKey: "gzctf"

    # Email configuration
    email:
      senderAddress: "noreply@example.com"
      userName: "noreply@example.com"
      password: ""
      smtp:
        host: smtp.example.com
        port: 587

    # Container provider configuration
    containerProvider:
      type: Kubernetes
      portMappingType: Default
      enableTrafficCapture: false
      # Public entry for the platform - CHANGE THIS to your domain!
      publicEntry: "ctf.example.com"

    # Request logging
    requestLogging: false

    # Rate limiting
    disableRateLimit: false

    # CAPTCHA configuration
    captcha:
      provider: "None" # Options: "None", "CloudflareTurnstile", "GoogleRecaptcha"
      siteKey: ""
      secretKey: ""

    # Container registries credentials
    registries: {}
      # Example:
      # ghcr.io:
      #   userName: "your-username"
      #   password: "ghp_your-token"

    # Forwarded headers configuration (for reverse proxy)
    forwardedOptions:
      forwardedHeaders: 15
      forwardLimit: 3
      # Trusted networks (add your ingress controller's network CIDR)
      trustedNetworks:
        - "10.0.0.0/8"
        # Example for common Kubernetes networks:
        # - "10.42.0.0/16"    # K3s default pod network
        # - "10.244.0.0/16"   # Flannel default

    # Telemetry configuration
    telemetry:
      enable: true
      prometheus:
        enable: true
      openTelemetry:
        enable: false
        protocol: Grpc
        endpointUri: ""

    # Kestrel configuration
    kestrel:
      limits:
        maxResponseBufferSize: 2048
        maxRequestBufferSize: 1048576
        maxRequestLineSize: 8192
        maxRequestHeadersTotalSize: 32768
        maxRequestHeaderCount: 100
        maxRequestBodySize: 134217728

# -- Image pull secrets for private container registries
  imagePullSecrets: []
  
  # -- Override the name of the chart
  nameOverride: ""
  
  # -- Override the full name of the chart
  fullnameOverride: ""

  # -- ServiceAccount configuration for GZCTF
  serviceAccount:
    # -- Create a ServiceAccount for GZCTF
    create: true
    # -- Automatically mount ServiceAccount token
    automount: true
    # -- Annotations to add to the ServiceAccount
    annotations: {}
    # -- ServiceAccount name (generated from chart fullname if not set)
    name: ""

  # -- Annotations to add to GZCTF pods
  podAnnotations: {}
  
  # -- Labels to add to GZCTF pods
  podLabels: {}

  # -- Security context for GZCTF pod
  podSecurityContext: {}
  
  # -- Security context for GZCTF container
  securityContext: {}

  # -- GZCTF service configuration
  service:
    # -- Annotations to add to the service
    annotations: {}
    # -- Service type
    type: ClusterIP
    # -- Service port
    port: 8080

  metrics:
    # -- Enable metrics port
    enabled: true
    # -- Metrics port number
    port: 3000

  # Ingress configuration for GZCTF
  ingress:
    # -- Enable ingress for GZCTF
    enabled: true
    # -- Ingress class name
    className: ""
    # -- Annotations for ingress resource
    annotations:
      traefik.ingress.kubernetes.io/service.sticky.cookie: "true"
      traefik.ingress.kubernetes.io/service.sticky.cookie.name: "LB_Session"
      traefik.ingress.kubernetes.io/service.sticky.cookie.httponly: "true"
    # -- Ingress hosts configuration
    hosts:
      - host: ctf.example.com
        paths:
          - path: /
            pathType: Prefix
    # -- TLS configuration for ingress
    tls: []

  # HTTPRoute configuration (Gateway API)
  # Gateway API is the next-generation traffic management API for Kubernetes
  # Requires Gateway API CRDs to be installed: https://gateway-api.sigs.k8s.io/
  httpRoute:
    # -- Enable HTTPRoute for GZCTF (requires Gateway API CRDs)
    enabled: false
    # -- Annotations for HTTPRoute resource
    annotations: {}

    # Reference to Gateway(s) that this HTTPRoute should attach to
    parentRefs:
      - name: gateway
        namespace: default
        # Optional: specify a section name for a specific listener
        # sectionName: https

    # Hostnames for HTTP request matching
    hostnames:
      - ctf.example.com

    # Advanced routing rules (optional)
    # If not specified, a default rule routing all traffic to GZCTF service will be created
    rules: []
      # Example: Path-based routing
      # - matches:
      #     - path:
      #         type: PathPrefix
      #         value: /
      #   backendRefs:
      #     - name: gzctf  # Will be auto-generated as release-name
      #       port: 8080
      #
      # Example: Header-based routing
      # - matches:
      #     - path:
      #         type: PathPrefix
      #         value: /api
      #       headers:
      #         - name: version
      #           value: v2
      #   backendRefs:
      #     - name: gzctf
      #       port: 8080

  # -- Resource requests and limits for GZCTF container
  resources:
    # -- Resource requests
    requests:
      # -- CPU request
      cpu: 1000m
      # -- Memory request
      memory: 384Mi

  # -- Liveness probe configuration
  livenessProbe:
    httpGet:
      path: /healthz
      port: metrics
  
  # -- Readiness probe configuration
  readinessProbe:
    httpGet:
      path: /healthz
      port: metrics

  autoscaling:
    # -- Enable autoscaling
    enabled: false
    # -- Minimum number of replicas
    minReplicas: 1
    # -- Maximum number of replicas
    maxReplicas: 100
    # -- Target CPU utilization percentage
    targetCPUUtilizationPercentage: 80
    # -- Target memory utilization percentage
    targetMemoryUtilizationPercentage: 80

  # Persistent Volume Claim configuration for GZCTF data
  pvc:
    # -- Create a PVC for GZCTF
    create: true
    # -- Storage class name for the PVC (empty string uses cluster default)
    storageClassName: standard
    # -- Access mode for the PVC (use ReadWriteMany when deploying multiple instances)
    accessMode: ReadWriteOnce # Either change to ReadWriteMany when deploying multiple instances or use S3 bucket(recommended) and set pvc.create to false
    # -- Size of the PVC
    size: 2Gi

  # -- Additional volumes for GZCTF pod
  volumes: []

  # -- Additional volume mounts for GZCTF container
  volumeMounts: []

  # -- Node labels for GZCTF pod assignment
  nodeSelector: {}

  # -- Tolerations for GZCTF pod scheduling
  tolerations: []

  # -- Affinity rules for GZCTF pod scheduling
  affinity: {}


# Garnet cache configuration (override the garnet subchart values)
garnet:
  # -- Enable Microsoft Garnet cache-store deployment
  enabled: false
  # -- Garnet container image configuration
  image:
    # -- Garnet image registry
    registry: ghcr.io
    # -- Garnet image repository
    repository: microsoft/garnet
    # -- Garnet image tag (empty string uses chart appVersion)
    tag: ""
  
  config:
    # -- Garnet secret (if you want to use an existing secret).
    # This secret must contains a key called 'garnet.conf'.
    existingSecret: ""
    # -- The garnet.conf data content.
    garnetConf: |
     {
       "AuthenticationMode": "Password",
       "Password": "gzctf"
     }
  
  # -- Persistent storage configuration for Garnet
  # @default -- Disabled (persistence not needed for cache)
  persistence:
    # -- Enable persistent storage for Garnet (not recommended for cache workloads)
    enabled: false


# Override the redis-ha subchart values
redis-ha:
  # -- Deploys a High-Availability Redis cluster
  enabled: false
  ## Redis image
  image:
    # -- Redis repository
    repository: public.ecr.aws/docker/library/redis
    # -- Redis tag
    tag: 7.2.11-alpine
  ## Prometheus redis-exporter sidecar
  exporter:
    # -- Enable Prometheus redis-exporter sidecar
    enabled: false
    # -- Repository to use for the redis-exporter
    image: ghcr.io/oliver006/redis_exporter
    # -- Tag to use for the redis-exporter
    tag: v1.78.0
  persistentVolume:
    # -- Configures persistence on Redis nodes
    enabled: false
  ## Redis specific configuration options
  redis:
    # -- Redis convention for naming the cluster group: must match `^[\\w-\\.]+$` and can be templated
    masterGroupName: gzctf
    # -- Any valid redis config options in this section will be applied to each server (see `redis-ha` chart)
    # @default -- See [values.yaml]
    config:
      # -- Will save the DB if both the given number of seconds and the given number of write operations against the DB occurred. `""`  is disabled
      # @default -- `'""'`
      save: '""'
  ## Enables a HA Proxy for better LoadBalancing / Sentinel Master support. Automatically proxies to Redis master.
  haproxy:
    # -- Enabled HAProxy LoadBalancing/Proxy
    enabled: true
    # --  Custom labels for the haproxy pod.
    labels:
      app.kubernetes.io/name: gzctf-redis-ha-haproxy
    metrics:
      # -- HAProxy enable prometheus metric scraping
      enabled: true
    # -- Whether the haproxy pods should be forced to run on separate nodes.
    hardAntiAffinity: true
    # -- Additional affinities to add to the haproxy pods.
    additionalAffinities: {}
    # -- Assign custom [affinity] rules to the haproxy pods.
    affinity: |

    # -- [Tolerations] for use with node taints for haproxy pods.
    tolerations: []
    # -- HAProxy container-level security context
    # @default -- See [values.yaml]
    containerSecurityContext:
      readOnlyRootFilesystem: true

  # -- Configures redis-ha with AUTH
  auth: true
  # -- (string) A password that configures a `requirepass` and `masterauth` in the conf parameters (Requires `auth: enabled`)
  redisPassword: gzctf

  # -- Whether the Redis server pods should be forced to run on separate nodes.
  hardAntiAffinity: true

  # -- Additional affinities to add to the Redis server pods.
  additionalAffinities: {}

  # -- Assign custom [affinity] rules to the Redis pods.
  affinity: |

  # -- [Tolerations] for use with node taints for Redis pods.
  tolerations: []

  # -- Assign custom [TopologySpreadConstraints] rules to the Redis pods.
  ## https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
  topologySpreadConstraints:
    # -- Enable Redis HA topology spread constraints
    enabled: false
    # -- Max skew of pods tolerated
    # @default -- `""` (defaults to `1`)
    maxSkew: ""
    # -- Topology key for spread
    # @default -- `""` (defaults to `topology.kubernetes.io/zone`)
    topologyKey: ""
    # -- Enforcement policy, hard or soft
    # @default -- `""` (defaults to `ScheduleAnyway`)
    whenUnsatisfiable: ""
  # -- Redis HA statefulset container-level security context
  # @default -- See [values.yaml]
  containerSecurityContext:
    readOnlyRootFilesystem: true

# PostgreSQL database configuration
postgresql:
  # -- Enable PostgreSQL deployment
  enabled: true
  
  # -- PostgreSQL image configuration
  image:
    # -- Docker registry for PostgreSQL image
    registry: docker.io
    # -- PostgreSQL image repository
    repository: postgres
    # -- PostgreSQL image tag
    tag: 16-alpine
    # -- Image pull policy
    pullPolicy: IfNotPresent
    # -- Image pull secrets for private registries
    imagePullSecrets: []
  
  # -- PostgreSQL service configuration
  service:
    # -- PostgreSQL service port
    port: 5432
  
  # -- Environment variables for PostgreSQL container
  env:
    # -- PostgreSQL password environment variable
    # @default -- Must match the database password in appsettings.json
    - name: POSTGRES_PASSWORD
      value: gzctf # Database password, needs to be consistent with the database password in appsettings.json
  
  podLabels: {}
  
  # PostgreSQL persistent storage configuration
  persistence:
    # -- Enable persistent storage for PostgreSQL
    enabled: true
    # -- Storage class name for persistent volume (empty string uses cluster default)
    storageClassName: ""
    # -- Size of the persistent volume
    size: 2Gi
    # -- Access mode for the persistent volume
    accessMode: ReadWriteOnce
  
  # -- Resource requests and limits for PostgreSQL container
  resources:
    # -- Resource requests
    requests:
      # -- CPU request
      cpu: 500m
      # -- Memory request
      memory: 512Mi
  
  # -- Liveness probe configuration for PostgreSQL container
  livenessProbe: {}
  
  # -- Readiness probe configuration for PostgreSQL container
  readinessProbe: {}
  
  # -- Annotations to add to PostgreSQL pods
  podAnnotations: {}
  
  # -- Security context for PostgreSQL pod
  podSecurityContext: {}
  
  # -- Security context for PostgreSQL container
  securityContext: {}
  
  # -- Additional volume mounts for PostgreSQL container
  volumeMounts: []
  
  # -- Additional volumes for PostgreSQL pod
  volumes: []
  
  # -- Node labels for PostgreSQL pod assignment
  nodeSelector: {}
  
  # -- Affinity rules for PostgreSQL pod scheduling
  affinity: {}
  
  # -- Tolerations for PostgreSQL pod scheduling
  tolerations: []



# PostgreSQL High Availability Configuration
# Bitnami PostgreSQL HA chart with replication manager
postgresql-ha:
  # -- Enable or disable PostgreSQL HA deployment (THIS USES BITNAMI LEGACY IMAGES BY DEFAULT WHICH NO LONGER RECIEVE RPOPER SECURITY UPDATES)
  enabled: false
  
  postgresql:
    # Container image configuration
    image:
      # -- Docker registry for PostgreSQL image
      registry: docker.io
      # -- PostgreSQL repository (bitnamilegacy repmgr version)
      repository: bitnamilegacy/postgresql-repmgr
      # -- PostgreSQL image tag (version 17.6.0)
      tag: 17.6.0-debian-12-r2
    # -- PostgreSQL superuser username
    username: "postgres"
    # -- PostgreSQL superuser password (should be overridden or use secrets)
    password: "gzctf"
    # -- Default database name to create
    database: "gzctf"


  pgpool:
    image:
      # -- pgpool image registry
      registry: docker.io
      # -- pgpool image repository
      repository: bitnamilegacy/pgpool
      # -- pgpool image tag
      tag: 4.6.3-debian-12-r0

  metrics:
    # -- postgresql exporter enable
    enabled: false
    image:
      # -- postgres-exporter image registry
      registry: docker.io
      # -- postgres-exporter image repository
      repository: bitnamilegacy/postgres-exporter
      # -- postgres-exporter image tag
      tag: 0.17.1-debian-12-r16

  # Volume permissions initialization
  volumePermissions:
    # -- Enable init container to set proper volume permissions
    enabled: true
    image:
      # -- volume-permissions image registry
      registry: docker.io
      # -- volume-permissions image repository
      repository: bitnamilegacy/os-shell
      # -- volume-permissions image tag
      tag: 12-debian-12-r51

  # Persistent storage configuration
  persistence:
    # -- Enable persistent volume for database storage
    enabled: true
    # -- Storage class name (empty string uses cluster default)
    storageClass: ""
    # -- Volume access mode
    accessMode: ReadWriteOnce
    # -- Persistent volume size
    size: 2Gi

# MinIO object storage configuration (override the minio subchart values)
minio:
  # -- Enable MinIO deployment (set to false if you want to use an external S3 bucket)
  enabled: false

  # -- MinIO container image configuration
  image:
    # -- MinIO image repository
    repository: quay.io/minio/minio
    # -- Image pull policy
    pullPolicy: IfNotPresent

  # -- MinIO bucket configuration
  buckets:
    # -- Default bucket to be used by GZCTF
    # @default -- `download` policy means this bucket is readonly for anonymous access (competitors)
    - name: gzctf-bucket
      # -- Bucket access policy (download = readonly for anonymous users)
      policy: download
      # -- Whether to purge the bucket on deletion
      purge: false
  
  # Ingress configuration for MinIO (used by both GZCTF and competitors)
  ingress:
    # -- Enable ingress for MinIO
    enabled: true
    # -- Hostnames for MinIO ingress
    hosts:
      - minio.example.com
    # -- Annotations for MinIO ingress
    annotations: {}
      # nginx.ingress.kubernetes.io/proxy-body-size: "0"
  
  # -- MinIO user
  rootUser: gzctf
  # -- MinIO password
  rootPassword: gzctf

  # -- Number of MinIO replicas/nodes
  replicas: 3
  
  # -- Number of drives per MinIO replica/node
  drivesPerNode: 1
  
  # -- Resource requests and limits for MinIO
  resources:
    # -- Resource requests for MinIO
    requests:
      # -- Memory request for MinIO
      memory: 2Gi
  
  # -- MinIO persistent storage configuration
  persistence:
    # -- Size of persistent volume for each MinIO instance (adjust according to your needs)
    size: 10Gi

# -- Additional Kubernetes manifests to deploy with this Helm chart
extraObjects: []
